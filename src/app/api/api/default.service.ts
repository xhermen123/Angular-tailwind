/**
 * Inbox API
 * Manage work for human moderators by adding, checking out and completing work items. Store User Generated Content to the database.  This will store it twice, once in short-term storage in it's exact form amd again in long term storage in it's redacted and pseudonymized form 
 *
 * OpenAPI spec version: 2.1.1
 * Contact: support@twohat.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { Ai } from '../model/ai';
import { Body } from '../model/body';
import { Body1 } from '../model/body1';
import { Body2 } from '../model/body2';
import { Checkout } from '../model/checkout';
import { Comment } from '../model/comment';
import { CommentInput } from '../model/commentInput';
import { Decision } from '../model/decision';
import { ExampleInput } from '../model/exampleInput';
import { ExampleOutput } from '../model/exampleOutput';
import { InlineResponse200 } from '../model/inlineResponse200';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { InlineResponse201 } from '../model/inlineResponse201';
import { ModeratorId } from '../model/moderatorId';
import { Queue } from '../model/queue';
import { RuleAuditInput } from '../model/ruleAuditInput';
import { RuleAuditOutput } from '../model/ruleAuditOutput';
import { SpellingMistakeInput } from '../model/spellingMistakeInput';
import { SpellingMistakeOutput } from '../model/spellingMistakeOutput';
import { TaskInput } from '../model/taskInput';
import { TaskOutput } from '../model/taskOutput';
import { Topics } from '../model/topics';
import { UsernameInput } from '../model/usernameInput';
import { UsernameOutput } from '../model/usernameOutput';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { DefaultServiceInterface }                            from './default.serviceInterface';


@Injectable({
    providedIn: 'root'
})
export class DefaultService implements DefaultServiceInterface {

    protected basePath = 'https://virtserver.swaggerhub.com/twohat/inbox/2.1.1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add a comment to this content item
     * Comments are ways to leave a note to say why a person made the decision they did.  Or it could be a question or answer trying to get help on an item. 
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addComment(queueId: string, contentId: string, body?: CommentInput, observe?: 'body', reportProgress?: boolean): Observable<Comment>;
    public addComment(queueId: string, contentId: string, body?: CommentInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;
    public addComment(queueId: string, contentId: string, body?: CommentInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;
    public addComment(queueId: string, contentId: string, body?: CommentInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling addComment.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling addComment.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Comment>('post',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/comments`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add examples of text to be reviewed
     * Add an example of short text for Quality Control.  This will later be used for  - Regression Tests | Once you mark an item as wrong and it is fixed you will want to be able to run it through the filter again to ensure the errors are not reproduced by creating future rules. - Examples | When reviewing things like spelling mistakes or rules it makes a huge difference to look at how words are really used.  For instance one might think that \&quot;made out\&quot; is sexual till they see the example \&quot;made out of plastic\&quot; - Training AI | We can improve the filter in the future by training AI to predict the risks and labels you provide and in so doing combine a rules based approach you can control with the fuzzy matching of AI to find similar things. 
     * @param body 
     * @param updateData If the item already exists should we update the values of the body element
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addExamples(body?: Array<ExampleInput>, updateData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse201>;
    public addExamples(body?: Array<ExampleInput>, updateData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse201>>;
    public addExamples(body?: Array<ExampleInput>, updateData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse201>>;
    public addExamples(body?: Array<ExampleInput>, updateData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateData !== undefined && updateData !== null) {
            queryParameters = queryParameters.set('updateData', <any>updateData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<InlineResponse201>('post',`${this.basePath}/inbox/queue/examples/items`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add rules to be audited
     * Our primary purpose is as a content filter.  To achieve this you can manually add word patterns to the system.  But how do you know if it is creating errors like false positives  To handle that we count how many times that rule is used in your new content and on key points like when it is said 100 times we bring it up here for review.  In this way you know you are working on the most impactful things first.  If the rule has already been added it will increase it&#x27;s priority.  Note that the request accepts an array of minimum 1 to maximum 100 items so you can do a bulk insert. 
     * @param body 
     * @param updateData If the item already exists should we update the values of the body element
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addRuleAuditItems(body?: Array<RuleAuditInput>, updateData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse201>;
    public addRuleAuditItems(body?: Array<RuleAuditInput>, updateData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse201>>;
    public addRuleAuditItems(body?: Array<RuleAuditInput>, updateData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse201>>;
    public addRuleAuditItems(body?: Array<RuleAuditInput>, updateData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateData !== undefined && updateData !== null) {
            queryParameters = queryParameters.set('updateData', <any>updateData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<InlineResponse201>('post',`${this.basePath}/inbox/queue/rulesAudit/items`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a common spelling mistake for review
     * One of the greatest impacts early on when you use the system is spelling mistakes, most often words unique to your product.  We automatically count which words are used and how often.  If it is frequently misspelled we will escalate it here. 
     * @param body 
     * @param updateData If the item already exists should we update the values of the body element
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addSpelling(body?: Array<SpellingMistakeInput>, updateData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse201>;
    public addSpelling(body?: Array<SpellingMistakeInput>, updateData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse201>>;
    public addSpelling(body?: Array<SpellingMistakeInput>, updateData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse201>>;
    public addSpelling(body?: Array<SpellingMistakeInput>, updateData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateData !== undefined && updateData !== null) {
            queryParameters = queryParameters.set('updateData', <any>updateData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<InlineResponse201>('post',`${this.basePath}/inbox/queue/spelling/items`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a task for the team to do work on
     * You can create a task to work on.  For example split all the sexting words into sexual body parts and sexual activity. 
     * @param body 
     * @param updateData If the item already exists should we update the values of the body element
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTaskItems(body?: Array<TaskInput>, updateData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse201>;
    public addTaskItems(body?: Array<TaskInput>, updateData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse201>>;
    public addTaskItems(body?: Array<TaskInput>, updateData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse201>>;
    public addTaskItems(body?: Array<TaskInput>, updateData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateData !== undefined && updateData !== null) {
            queryParameters = queryParameters.set('updateData', <any>updateData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<InlineResponse201>('post',`${this.basePath}/inbox/queue/task/items`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add usernames to be reviewed
     * Add an example of a username for Quality Control.  This will later be used for  - Regression Tests | Once you mark an item as wrong and it is fixed you will want to be able to run it through the filter again to ensure the errors are not reproduced by creating future rules. - Training AI | We can improve the filter in the future by training AI to predict the risks and labels you provide and in so doing combine a rules based approach you can control with the fuzzy matching of AI to find similar things. 
     * @param body 
     * @param updateData If the item already exists should we update the values of the body element
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addUseranmes(body?: Array<UsernameInput>, updateData?: boolean, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse201>;
    public addUseranmes(body?: Array<UsernameInput>, updateData?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse201>>;
    public addUseranmes(body?: Array<UsernameInput>, updateData?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse201>>;
    public addUseranmes(body?: Array<UsernameInput>, updateData?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateData !== undefined && updateData !== null) {
            queryParameters = queryParameters.set('updateData', <any>updateData);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<InlineResponse201>('post',`${this.basePath}/inbox/queue/usernames/items`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all items in this queue
     this may take some time and this server may be scaled out we will setup a long running task to accomplish this and that will restart if doesn&#x27;t finish.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param languages Which languages does this apply to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deletExampleItems(clientId?: number, languages?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deletExampleItems(clientId?: number, languages?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deletExampleItems(clientId?: number, languages?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deletExampleItems(clientId?: number, languages?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/inbox/queue/examples/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Release all checkouts on a queue
     * Sometimes people go for coffee and still have items checked out.  When you get down to a few items left this can be a problem.  This will free up all non-expiring checkouts. 
     * @param queueId The unique identifier for this queue
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param languages Which languages does this apply to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAllCheckouts(queueId: string, clientId?: number, languages?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2001>;
    public deleteAllCheckouts(queueId: string, clientId?: number, languages?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2001>>;
    public deleteAllCheckouts(queueId: string, clientId?: number, languages?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2001>>;
    public deleteAllCheckouts(queueId: string, clientId?: number, languages?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling deleteAllCheckouts.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2001>('delete',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/checkout`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a comment
     * Remove a comment
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param commentId The unique identifier for the comment
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteComment(queueId: string, contentId: string, commentId: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2001>;
    public deleteComment(queueId: string, contentId: string, commentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2001>>;
    public deleteComment(queueId: string, contentId: string, commentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2001>>;
    public deleteComment(queueId: string, contentId: string, commentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling deleteComment.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling deleteComment.');
        }

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling deleteComment.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2001>('delete',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/comments/${encodeURIComponent(String(commentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Abandon a checkout
     * Remove a checkout assigned to you without doing any work.
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteItemCheckout(queueId: string, contentId: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2001>;
    public deleteItemCheckout(queueId: string, contentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2001>>;
    public deleteItemCheckout(queueId: string, contentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2001>>;
    public deleteItemCheckout(queueId: string, contentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling deleteItemCheckout.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling deleteItemCheckout.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2001>('delete',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/checkout`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all items in this queue
     this may take some time and this server may be scaled out we will setup a long running task to accomplish this and that will restart if doesn&#x27;t finish.
     * @param queueId The unique identifier for this queue
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param languages Which languages does this apply to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteItems(queueId: string, clientId?: number, languages?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;
    public deleteItems(queueId: string, clientId?: number, languages?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;
    public deleteItems(queueId: string, clientId?: number, languages?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;
    public deleteItems(queueId: string, clientId?: number, languages?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling deleteItems.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse200>('delete',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a param
     * Delete a param and use the default instead
     * @param queueId The unique identifier for this queue
     * @param paramId A custom configuration for a client
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteParam(queueId: string, paramId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteParam(queueId: string, paramId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteParam(queueId: string, paramId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteParam(queueId: string, paramId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling deleteParam.');
        }

        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling deleteParam.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/param/${encodeURIComponent(String(paramId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all items in this queue
     this may take some time and this server may be scaled out we will setup a long running task to accomplish this and that will restart if doesn&#x27;t finish.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param languages Which languages does this apply to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteRuleAuditItems(clientId?: number, languages?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteRuleAuditItems(clientId?: number, languages?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteRuleAuditItems(clientId?: number, languages?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteRuleAuditItems(clientId?: number, languages?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/inbox/queue/rulesAudit/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all items in this queue
     this may take some time and this server may be scaled out we will setup a long running task to accomplish this and that will restart if doesn&#x27;t finish.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param languages Which languages does this apply to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteSpellingItems(clientId?: number, languages?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteSpellingItems(clientId?: number, languages?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteSpellingItems(clientId?: number, languages?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteSpellingItems(clientId?: number, languages?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/inbox/queue/spelling/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all items in this queue
     this may take some time and this server may be scaled out we will setup a long running task to accomplish this and that will restart if doesn&#x27;t finish.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param languages Which languages does this apply to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTaskItems(clientId?: number, languages?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteTaskItems(clientId?: number, languages?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteTaskItems(clientId?: number, languages?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteTaskItems(clientId?: number, languages?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/inbox/queue/task/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a users data
     * This will delete all data we have on a user. This is recommended for GDPR and CCPA compliance around terms like right to be forgetten.  Probably what you want instead however is to pseudonymize all the data with a put request instead. 
     * @param userId The unique identifier for this user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteUser(userId: string, observe?: 'body', reportProgress?: boolean): Observable<Queue>;
    public deleteUser(userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;
    public deleteUser(userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;
    public deleteUser(userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteUser.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Queue>('delete',`${this.basePath}/inbox/user/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all items in this queue
     this may take some time and this server may be scaled out we will setup a long running task to accomplish this and that will restart if doesn&#x27;t finish.
     * @param clientId Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to.
     * @param languages Which languages does this apply to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteUsernameItems(clientId?: number, languages?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteUsernameItems(clientId?: number, languages?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteUsernameItems(clientId?: number, languages?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteUsernameItems(clientId?: number, languages?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (languages) {
            languages.forEach((element) => {
                queryParameters = queryParameters.append('languages', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/inbox/queue/usernames/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a comments
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComments(queueId: string, contentId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Comment>>;
    public getComments(queueId: string, contentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Comment>>>;
    public getComments(queueId: string, contentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Comment>>>;
    public getComments(queueId: string, contentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling getComment.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling getComment.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Comment>('get',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/comments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a comment
     * Get a comment by Id for this item
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param commentId The unique identifier for the comment
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComment(queueId: string, contentId: string, commentId: string, observe?: 'body', reportProgress?: boolean): Observable<Comment>;
    public getComment(queueId: string, contentId: string, commentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;
    public getComment(queueId: string, contentId: string, commentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;
    public getComment(queueId: string, contentId: string, commentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling getComment.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling getComment.');
        }

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling getComment.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Comment>('get',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/comments/${encodeURIComponent(String(commentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for or checkout items in this queue
     * Lookup items for this queue
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param ai Show items the AI predicts as useful because moderators in the past have taken an action on this items.  Passing an array of objects as params can be tricky at first so here is an example &amp;ai[0][minPrediction]&#x3D;0.50&amp;ai[0][modelName]&#x3D;topic_vulgar&amp;ai[0][maxPrediction]&#x3D;0.95&amp;ai[1][minPrediction]&#x3D;0.10&amp;ai[1][modelName]&#x3D;topic_fraud&amp;ai[1][maxPrediction]&#x3D;0.80  In urlencoded form that would be &amp;ai%5B0%5D%5BminPrediction%5D&#x3D;0.50&amp;ai%5B0%5D%5BmodelName%5D&#x3D;topic_vulgar&amp;ai%5B0%5D%5BmaxPrediction%5D&#x3D;0.95&amp;ai%5B1%5D%5BminPrediction%5D&#x3D;0.10&amp;ai%5B1%5D%5BmodelName%5D&#x3D;topic_fraud&amp;ai%5B1%5D%5BmaxPrediction%5D&#x3D;0.80 
     * @param checkout Checkout this item for review
     * @param clientIds Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to. You can set this to -1 to apply to all clients you have access to.
     * @param contentIds Get these specific contentIds.  Frequently used when you use the Previous button.
     * @param notContentIds Exclude these specific contentIds.  Originally designed so you can call checkout and pass in the item you are working on right now and it will give you a different one.  The default checkout behaviour will assign the items you already have checked out  (which is on your screen). 
     * @param endDate Show results occurring before the given date in unixtimestamp (milliseconds since Epoch)
     * @param startDate Show results occurring after the given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedStartDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedEndDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param checkoutAvailable Only show items where the item could be checked out by me.  This is the same as checkout&#x3D;true but it does not check it out.
     * @param doneByModeratorId Only show work done by this moderatorId
     * @param limit Limit the number of results
     * @param offset Start the search from offset 0.  For instance if your using pagination page 2 would be on totalItemsPerPage*pageNum. 
     * @param sortBy What do you want to sort the results by  - FIFO | First in First Out, the same order they came in - Recent | Handle the most recent items first - Priority | By priority (if applicable).  For quality control like spelling it is the times used so it will show the items misspelled 1000 times before the ones 500 times.  For reported users it will be the ones where multiple users have reported the same user. - AI | Deal with the higest AI predictions first that predict this should be relevant for me.  (NOTE: to search by AI you must also have set the ai.modelName in the first item of the parameter ai) 
     * @param tags Only find items matching a certain tag
     * @param text Text search.  This uses fuzzy matching.
     * @param topics Only show items for these topics (topicId) between risk level minRisk and maxRisk
     * @param unresolvedComments Will see if there are any unresolved comments for you and show only those
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExamples(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ExampleOutput>;
    public getExamples(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ExampleOutput>>;
    public getExamples(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExampleOutput>>;
    public getExamples(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling getExamples.');
        }



















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ai) {
            ai.forEach((element) => {
                queryParameters = queryParameters.append('ai', <any>element);
            })
        }
        if (checkout !== undefined && checkout !== null) {
            queryParameters = queryParameters.set('checkout', <any>checkout);
        }
        if (clientIds) {
            queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));
        }
        if (contentIds) {
            queryParameters = queryParameters.set('contentIds', contentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (notContentIds) {
            queryParameters = queryParameters.set('notContentIds', notContentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (reviewedStartDate !== undefined && reviewedStartDate !== null) {
            queryParameters = queryParameters.set('reviewedStartDate', <any>reviewedStartDate);
        }
        if (reviewedEndDate !== undefined && reviewedEndDate !== null) {
            queryParameters = queryParameters.set('reviewedEndDate', <any>reviewedEndDate);
        }
        if (checkoutAvailable !== undefined && checkoutAvailable !== null) {
            queryParameters = queryParameters.set('checkoutAvailable', <any>checkoutAvailable);
        }
        if (doneByModeratorId !== undefined && doneByModeratorId !== null) {
            queryParameters = queryParameters.set('doneByModeratorId', <any>doneByModeratorId);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (tags) {
            queryParameters = queryParameters.set('tags', tags.join(COLLECTION_FORMATS['csv']));
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (topics) {
            topics.forEach((element) => {
                queryParameters = queryParameters.append('topics', <any>element);
            })
        }
        if (unresolvedComments !== undefined && unresolvedComments !== null) {
            queryParameters = queryParameters.set('unresolvedComments', <any>unresolvedComments);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ExampleOutput>('get',`${this.basePath}/inbox/queue/examples/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * list all queues with pending and total counts
     * Will list all the queues that are available and the count of items in them
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getInbox(observe?: 'body', reportProgress?: boolean): Observable<Array<Queue>>;
    public getInbox(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Queue>>>;
    public getInbox(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Queue>>>;
    public getInbox(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Queue>>('get',`${this.basePath}/inbox`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the checkout for this item
     * Get the checkout for this item
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getItemCheckout(queueId: string, contentId: string, observe?: 'body', reportProgress?: boolean): Observable<Checkout>;
    public getItemCheckout(queueId: string, contentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Checkout>>;
    public getItemCheckout(queueId: string, contentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Checkout>>;
    public getItemCheckout(queueId: string, contentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling getItemCheckout.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling getItemCheckout.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Checkout>('get',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/checkout`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the queue
     * A Queue is a group of work to be done by moderators.  This will get the queue and it&#x27;s information
     * @param queueId The unique identifier for this queue
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getQueue(queueId: string, observe?: 'body', reportProgress?: boolean): Observable<Queue>;
    public getQueue(queueId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;
    public getQueue(queueId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;
    public getQueue(queueId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling getQueue.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Queue>('get',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for items in this queue
     * Lookup items for this queue
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param ai Show items the AI predicts as useful because moderators in the past have taken an action on this items.  Passing an array of objects as params can be tricky at first so here is an example &amp;ai[0][minPrediction]&#x3D;0.50&amp;ai[0][modelName]&#x3D;topic_vulgar&amp;ai[0][maxPrediction]&#x3D;0.95&amp;ai[1][minPrediction]&#x3D;0.10&amp;ai[1][modelName]&#x3D;topic_fraud&amp;ai[1][maxPrediction]&#x3D;0.80  In urlencoded form that would be &amp;ai%5B0%5D%5BminPrediction%5D&#x3D;0.50&amp;ai%5B0%5D%5BmodelName%5D&#x3D;topic_vulgar&amp;ai%5B0%5D%5BmaxPrediction%5D&#x3D;0.95&amp;ai%5B1%5D%5BminPrediction%5D&#x3D;0.10&amp;ai%5B1%5D%5BmodelName%5D&#x3D;topic_fraud&amp;ai%5B1%5D%5BmaxPrediction%5D&#x3D;0.80 
     * @param checkout Checkout this item for review
     * @param clientIds Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to. You can set this to -1 to apply to all clients you have access to.
     * @param contentIds Get these specific contentIds.  Frequently used when you use the Previous button.
     * @param notContentIds Exclude these specific contentIds.  Originally designed so you can call checkout and pass in the item you are working on right now and it will give you a different one.  The default checkout behaviour will assign the items you already have checked out  (which is on your screen). 
     * @param endDate Show results occurring before the given date in unixtimestamp (milliseconds since Epoch)
     * @param startDate Show results occurring after the given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedStartDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedEndDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param checkoutAvailable Only show items where the item could be checked out by me.  This is the same as checkout&#x3D;true but it does not check it out.
     * @param doneByModeratorId Only show work done by this moderatorId
     * @param limit Limit the number of results
     * @param offset Start the search from offset 0.  For instance if your using pagination page 2 would be on totalItemsPerPage*pageNum. 
     * @param sortBy What do you want to sort the results by  - FIFO | First in First Out, the same order they came in - Recent | Handle the most recent items first - Priority | By priority (if applicable).  For quality control like spelling it is the times used so it will show the items misspelled 1000 times before the ones 500 times.  For reported users it will be the ones where multiple users have reported the same user. - AI | Deal with the higest AI predictions first that predict this should be relevant for me.  (NOTE: to search by AI you must also have set the ai.modelName in the first item of the parameter ai) 
     * @param tags Only find items matching a certain tag
     * @param text Text search.  This uses fuzzy matching.
     * @param topics Only show items for these topics (topicId) between risk level minRisk and maxRisk
     * @param unresolvedComments Will see if there are any unresolved comments for you and show only those
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRuleAuditItems(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'body', reportProgress?: boolean): Observable<RuleAuditOutput>;
    public getRuleAuditItems(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RuleAuditOutput>>;
    public getRuleAuditItems(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RuleAuditOutput>>;
    public getRuleAuditItems(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling getRuleAuditItems.');
        }



















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ai) {
            ai.forEach((element) => {
                queryParameters = queryParameters.append('ai', <any>element);
            })
        }
        if (checkout !== undefined && checkout !== null) {
            queryParameters = queryParameters.set('checkout', <any>checkout);
        }
        if (clientIds) {
            queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));
        }
        if (contentIds) {
            queryParameters = queryParameters.set('contentIds', contentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (notContentIds) {
            queryParameters = queryParameters.set('notContentIds', notContentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (reviewedStartDate !== undefined && reviewedStartDate !== null) {
            queryParameters = queryParameters.set('reviewedStartDate', <any>reviewedStartDate);
        }
        if (reviewedEndDate !== undefined && reviewedEndDate !== null) {
            queryParameters = queryParameters.set('reviewedEndDate', <any>reviewedEndDate);
        }
        if (checkoutAvailable !== undefined && checkoutAvailable !== null) {
            queryParameters = queryParameters.set('checkoutAvailable', <any>checkoutAvailable);
        }
        if (doneByModeratorId !== undefined && doneByModeratorId !== null) {
            queryParameters = queryParameters.set('doneByModeratorId', <any>doneByModeratorId);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (tags) {
            queryParameters = queryParameters.set('tags', tags.join(COLLECTION_FORMATS['csv']));
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (topics) {
            topics.forEach((element) => {
                queryParameters = queryParameters.append('topics', <any>element);
            })
        }
        if (unresolvedComments !== undefined && unresolvedComments !== null) {
            queryParameters = queryParameters.set('unresolvedComments', <any>unresolvedComments);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RuleAuditOutput>('get',`${this.basePath}/inbox/queue/rulesAudit/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for or checkout items in this queue
     * Lookup items for this queue
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param ai Show items the AI predicts as useful because moderators in the past have taken an action on this items.  Passing an array of objects as params can be tricky at first so here is an example &amp;ai[0][minPrediction]&#x3D;0.50&amp;ai[0][modelName]&#x3D;topic_vulgar&amp;ai[0][maxPrediction]&#x3D;0.95&amp;ai[1][minPrediction]&#x3D;0.10&amp;ai[1][modelName]&#x3D;topic_fraud&amp;ai[1][maxPrediction]&#x3D;0.80  In urlencoded form that would be &amp;ai%5B0%5D%5BminPrediction%5D&#x3D;0.50&amp;ai%5B0%5D%5BmodelName%5D&#x3D;topic_vulgar&amp;ai%5B0%5D%5BmaxPrediction%5D&#x3D;0.95&amp;ai%5B1%5D%5BminPrediction%5D&#x3D;0.10&amp;ai%5B1%5D%5BmodelName%5D&#x3D;topic_fraud&amp;ai%5B1%5D%5BmaxPrediction%5D&#x3D;0.80 
     * @param checkout Checkout this item for review
     * @param clientIds Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to. You can set this to -1 to apply to all clients you have access to.
     * @param contentIds Get these specific contentIds.  Frequently used when you use the Previous button.
     * @param notContentIds Exclude these specific contentIds.  Originally designed so you can call checkout and pass in the item you are working on right now and it will give you a different one.  The default checkout behaviour will assign the items you already have checked out  (which is on your screen). 
     * @param endDate Show results occurring before the given date in unixtimestamp (milliseconds since Epoch)
     * @param startDate Show results occurring after the given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedStartDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedEndDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param checkoutAvailable Only show items where the item could be checked out by me.  This is the same as checkout&#x3D;true but it does not check it out.
     * @param doneByModeratorId Only show work done by this moderatorId
     * @param limit Limit the number of results
     * @param offset Start the search from offset 0.  For instance if your using pagination page 2 would be on totalItemsPerPage*pageNum. 
     * @param sortBy What do you want to sort the results by  - FIFO | First in First Out, the same order they came in - Recent | Handle the most recent items first - Priority | By priority (if applicable).  For quality control like spelling it is the times used so it will show the items misspelled 1000 times before the ones 500 times.  For reported users it will be the ones where multiple users have reported the same user. - AI | Deal with the higest AI predictions first that predict this should be relevant for me.  (NOTE: to search by AI you must also have set the ai.modelName in the first item of the parameter ai) 
     * @param tags Only find items matching a certain tag
     * @param text Text search.  This uses fuzzy matching.
     * @param topics Only show items for these topics (topicId) between risk level minRisk and maxRisk
     * @param unresolvedComments Will see if there are any unresolved comments for you and show only those
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSpelling(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'body', reportProgress?: boolean): Observable<SpellingMistakeOutput>;
    public getSpelling(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SpellingMistakeOutput>>;
    public getSpelling(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SpellingMistakeOutput>>;
    public getSpelling(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling getSpelling.');
        }



















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ai) {
            ai.forEach((element) => {
                queryParameters = queryParameters.append('ai', <any>element);
            })
        }
        if (checkout !== undefined && checkout !== null) {
            queryParameters = queryParameters.set('checkout', <any>checkout);
        }
        if (clientIds) {
            queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));
        }
        if (contentIds) {
            queryParameters = queryParameters.set('contentIds', contentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (notContentIds) {
            queryParameters = queryParameters.set('notContentIds', notContentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (reviewedStartDate !== undefined && reviewedStartDate !== null) {
            queryParameters = queryParameters.set('reviewedStartDate', <any>reviewedStartDate);
        }
        if (reviewedEndDate !== undefined && reviewedEndDate !== null) {
            queryParameters = queryParameters.set('reviewedEndDate', <any>reviewedEndDate);
        }
        if (checkoutAvailable !== undefined && checkoutAvailable !== null) {
            queryParameters = queryParameters.set('checkoutAvailable', <any>checkoutAvailable);
        }
        if (doneByModeratorId !== undefined && doneByModeratorId !== null) {
            queryParameters = queryParameters.set('doneByModeratorId', <any>doneByModeratorId);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (tags) {
            queryParameters = queryParameters.set('tags', tags.join(COLLECTION_FORMATS['csv']));
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (topics) {
            topics.forEach((element) => {
                queryParameters = queryParameters.append('topics', <any>element);
            })
        }
        if (unresolvedComments !== undefined && unresolvedComments !== null) {
            queryParameters = queryParameters.set('unresolvedComments', <any>unresolvedComments);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SpellingMistakeOutput>('get',`${this.basePath}/inbox/queue/spelling/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for tasks in the queue
     * Lookup items for this queue
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param clientIds Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to. You can set this to -1 to apply to all clients you have access to.
     * @param contentIds Get these specific contentIds.  Frequently used when you use the Previous button.
     * @param notContentIds Exclude these specific contentIds.  Originally designed so you can call checkout and pass in the item you are working on right now and it will give you a different one.  The default checkout behaviour will assign the items you already have checked out  (which is on your screen). 
     * @param endDate Show results occurring before the given date in unixtimestamp (milliseconds since Epoch)
     * @param startDate Show results occurring after the given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedStartDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedEndDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param checkoutAvailable Only show items where the item could be checked out by me.  This is the same as checkout&#x3D;true but it does not check it out.
     * @param doneByModeratorId Only show work done by this moderatorId
     * @param assignedToModeratorId Show items assigned to this moderator
     * @param limit Limit the number of results
     * @param offset Start the search from offset 0.  For instance if your using pagination page 2 would be on totalItemsPerPage*pageNum. 
     * @param sortBy What do you want to sort the results by  - FIFO | First in First Out, the same order they came in - Recent | Handle the most recent items first - Priority | By priority (if applicable).  For quality control like spelling it is the times used so it will show the items misspelled 1000 times before the ones 500 times.  For reported users it will be the ones where multiple users have reported the same user. - AI | Deal with the higest AI predictions first that predict this should be relevant for me.  (NOTE: to search by AI you must also have set the ai.modelName in the first item of the parameter ai) 
     * @param tags Only find items matching a certain tag
     * @param text Text search.  This uses fuzzy matching.
     * @param unresolvedComments Will see if there are any unresolved comments for you and show only those
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTaskItems(language: string, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, assignedToModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, unresolvedComments?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TaskOutput>;
    public getTaskItems(language: string, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, assignedToModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, unresolvedComments?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskOutput>>;
    public getTaskItems(language: string, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, assignedToModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, unresolvedComments?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskOutput>>;
    public getTaskItems(language: string, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, assignedToModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, unresolvedComments?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling getTaskItems.');
        }

















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientIds) {
            queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));
        }
        if (contentIds) {
            queryParameters = queryParameters.set('contentIds', contentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (notContentIds) {
            queryParameters = queryParameters.set('notContentIds', notContentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (reviewedStartDate !== undefined && reviewedStartDate !== null) {
            queryParameters = queryParameters.set('reviewedStartDate', <any>reviewedStartDate);
        }
        if (reviewedEndDate !== undefined && reviewedEndDate !== null) {
            queryParameters = queryParameters.set('reviewedEndDate', <any>reviewedEndDate);
        }
        if (checkoutAvailable !== undefined && checkoutAvailable !== null) {
            queryParameters = queryParameters.set('checkoutAvailable', <any>checkoutAvailable);
        }
        if (doneByModeratorId !== undefined && doneByModeratorId !== null) {
            queryParameters = queryParameters.set('doneByModeratorId', <any>doneByModeratorId);
        }
        if (assignedToModeratorId !== undefined && assignedToModeratorId !== null) {
            queryParameters = queryParameters.set('assignedToModeratorId', <any>assignedToModeratorId);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (tags) {
            queryParameters = queryParameters.set('tags', tags.join(COLLECTION_FORMATS['csv']));
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (unresolvedComments !== undefined && unresolvedComments !== null) {
            queryParameters = queryParameters.set('unresolvedComments', <any>unresolvedComments);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<TaskOutput>('get',`${this.basePath}/inbox/queue/task/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a users data
     * This will retrieve all information on a user.  This is recommended for GDPR around right to access.  It can also be used if you are downloading a report to send in to the police around criminal activity. 
     * @param userId The unique identifier for this user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserData(userId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public getUserData(userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public getUserData(userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public getUserData(userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserData.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/x-ndjson',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<any>>('get',`${this.basePath}/inbox/user/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for or checkout items in this queue
     * Lookup items for this queue
     * @param language Show results for the given language only.   This is the language used, could have been set by the user or detected by language id.
     * @param ai Show items the AI predicts as useful because moderators in the past have taken an action on this items.  Passing an array of objects as params can be tricky at first so here is an example &amp;ai[0][minPrediction]&#x3D;0.50&amp;ai[0][modelName]&#x3D;topic_vulgar&amp;ai[0][maxPrediction]&#x3D;0.95&amp;ai[1][minPrediction]&#x3D;0.10&amp;ai[1][modelName]&#x3D;topic_fraud&amp;ai[1][maxPrediction]&#x3D;0.80  In urlencoded form that would be &amp;ai%5B0%5D%5BminPrediction%5D&#x3D;0.50&amp;ai%5B0%5D%5BmodelName%5D&#x3D;topic_vulgar&amp;ai%5B0%5D%5BmaxPrediction%5D&#x3D;0.95&amp;ai%5B1%5D%5BminPrediction%5D&#x3D;0.10&amp;ai%5B1%5D%5BmodelName%5D&#x3D;topic_fraud&amp;ai%5B1%5D%5BmaxPrediction%5D&#x3D;0.80 
     * @param checkout Checkout this item for review
     * @param clientIds Show results for a given client.  Typically this is set for you by the internal system based on the API_KEY you are using.  However some clients are allowed to view other clients such as when they have a sandbox or when they are a large enterprise and have multiple clients they manage.  It will only allow you to view client data you have access to. You can set this to -1 to apply to all clients you have access to.
     * @param contentIds Get these specific contentIds.  Frequently used when you use the Previous button.
     * @param notContentIds Exclude these specific contentIds.  Originally designed so you can call checkout and pass in the item you are working on right now and it will give you a different one.  The default checkout behaviour will assign the items you already have checked out  (which is on your screen). 
     * @param endDate Show results occurring before the given date in unixtimestamp (milliseconds since Epoch)
     * @param startDate Show results occurring after the given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedStartDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param reviewedEndDate Show results that where reviewed between given date in unixtimestamp (milliseconds since Epoch)
     * @param checkoutAvailable Only show items where the item could be checked out by me.  This is the same as checkout&#x3D;true but it does not check it out.
     * @param doneByModeratorId Only show work done by this moderatorId
     * @param limit Limit the number of results
     * @param offset Start the search from offset 0.  For instance if your using pagination page 2 would be on totalItemsPerPage*pageNum. 
     * @param sortBy What do you want to sort the results by  - FIFO | First in First Out, the same order they came in - Recent | Handle the most recent items first - Priority | By priority (if applicable).  For quality control like spelling it is the times used so it will show the items misspelled 1000 times before the ones 500 times.  For reported users it will be the ones where multiple users have reported the same user. - AI | Deal with the higest AI predictions first that predict this should be relevant for me.  (NOTE: to search by AI you must also have set the ai.modelName in the first item of the parameter ai) 
     * @param tags Only find items matching a certain tag
     * @param text Text search.  This uses fuzzy matching.
     * @param topics Only show items for these topics (topicId) between risk level minRisk and maxRisk
     * @param unresolvedComments Will see if there are any unresolved comments for you and show only those
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUsernames(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'body', reportProgress?: boolean): Observable<UsernameOutput>;
    public getUsernames(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UsernameOutput>>;
    public getUsernames(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UsernameOutput>>;
    public getUsernames(language: string, ai?: Array<Ai>, checkout?: boolean, clientIds?: Array<number>, contentIds?: Array<string>, notContentIds?: Array<string>, endDate?: number, startDate?: number, reviewedStartDate?: number, reviewedEndDate?: number, checkoutAvailable?: boolean, doneByModeratorId?: ModeratorId, limit?: number, offset?: number, sortBy?: string, tags?: Array<string>, text?: string, topics?: Array<Topics>, unresolvedComments?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling getUsernames.');
        }



















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ai) {
            ai.forEach((element) => {
                queryParameters = queryParameters.append('ai', <any>element);
            })
        }
        if (checkout !== undefined && checkout !== null) {
            queryParameters = queryParameters.set('checkout', <any>checkout);
        }
        if (clientIds) {
            queryParameters = queryParameters.set('clientIds', clientIds.join(COLLECTION_FORMATS['csv']));
        }
        if (contentIds) {
            queryParameters = queryParameters.set('contentIds', contentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (notContentIds) {
            queryParameters = queryParameters.set('notContentIds', notContentIds.join(COLLECTION_FORMATS['csv']));
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (reviewedStartDate !== undefined && reviewedStartDate !== null) {
            queryParameters = queryParameters.set('reviewedStartDate', <any>reviewedStartDate);
        }
        if (reviewedEndDate !== undefined && reviewedEndDate !== null) {
            queryParameters = queryParameters.set('reviewedEndDate', <any>reviewedEndDate);
        }
        if (checkoutAvailable !== undefined && checkoutAvailable !== null) {
            queryParameters = queryParameters.set('checkoutAvailable', <any>checkoutAvailable);
        }
        if (doneByModeratorId !== undefined && doneByModeratorId !== null) {
            queryParameters = queryParameters.set('doneByModeratorId', <any>doneByModeratorId);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (tags) {
            queryParameters = queryParameters.set('tags', tags.join(COLLECTION_FORMATS['csv']));
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (topics) {
            topics.forEach((element) => {
                queryParameters = queryParameters.append('topics', <any>element);
            })
        }
        if (unresolvedComments !== undefined && unresolvedComments !== null) {
            queryParameters = queryParameters.set('unresolvedComments', <any>unresolvedComments);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UsernameOutput>('get',`${this.basePath}/inbox/queue/usernames/items`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add your decision to this content item
     * This will   - Release your checkout on the item  - Record how long you spent on it (should be total items on screen / seconds since started minus any pauses)  - record what the current risk is when reviewed (if applicable)  - record what tags you set it as (including the decision you made where ban user, agree, disagree, delete content are all tags) 
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public itemDone(queueId: string, contentId: string, body?: Decision, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse201>;
    public itemDone(queueId: string, contentId: string, body?: Decision, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse201>>;
    public itemDone(queueId: string, contentId: string, body?: Decision, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse201>>;
    public itemDone(queueId: string, contentId: string, body?: Decision, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling itemDone.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling itemDone.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<InlineResponse201>('post',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/decision`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List comments on this content item
     * 
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listCommentsForContentId(queueId: string, contentId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Comment>>;
    public listCommentsForContentId(queueId: string, contentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Comment>>>;
    public listCommentsForContentId(queueId: string, contentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Comment>>>;
    public listCommentsForContentId(queueId: string, contentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling listCommentsForContentId.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling listCommentsForContentId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Comment>>('get',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/comments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the text of an item
     * Update the content.  Typically used for redacting.  It is limited in what you can do. 
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public redactItem(queueId: string, contentId: string, body?: Body, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2001>;
    public redactItem(queueId: string, contentId: string, body?: Body, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2001>>;
    public redactItem(queueId: string, contentId: string, body?: Body, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2001>>;
    public redactItem(queueId: string, contentId: string, body?: Body, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling redactItem.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling redactItem.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<InlineResponse2001>('put',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/text`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Redact a users data
     * This will redact and pseudonymize all data we have on a user. This is recommended for GDPR and CCPA compliance around terms like right to be forgetten. 
     * @param userId The unique identifier for this user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public redactUser(userId: string, observe?: 'body', reportProgress?: boolean): Observable<Queue>;
    public redactUser(userId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;
    public redactUser(userId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;
    public redactUser(userId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling redactUser.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Queue>('put',`${this.basePath}/inbox/user/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Mark a comment as resolved (or reopen)
     * Comments can be marked as needing to be answered. 
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param commentId The unique identifier for the comment
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resolveComment(queueId: string, contentId: string, commentId: string, body?: Body1, observe?: 'body', reportProgress?: boolean): Observable<Comment>;
    public resolveComment(queueId: string, contentId: string, commentId: string, body?: Body1, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;
    public resolveComment(queueId: string, contentId: string, commentId: string, body?: Body1, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;
    public resolveComment(queueId: string, contentId: string, commentId: string, body?: Body1, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling resolveComment.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling resolveComment.');
        }

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling resolveComment.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Comment>('put',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/comments/${encodeURIComponent(String(commentId))}/resolved`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a comment
     * Comments are ways to leave a note to say why a person made the decision they did.  Or it could be a question or answer trying to get help on an item. 
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param commentId The unique identifier for the comment
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateComment(queueId: string, contentId: string, commentId: string, body?: Comment, observe?: 'body', reportProgress?: boolean): Observable<Comment>;
    public updateComment(queueId: string, contentId: string, commentId: string, body?: Comment, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comment>>;
    public updateComment(queueId: string, contentId: string, commentId: string, body?: Comment, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comment>>;
    public updateComment(queueId: string, contentId: string, commentId: string, body?: Comment, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling updateComment.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling updateComment.');
        }

        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling updateComment.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Comment>('put',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/comments/${encodeURIComponent(String(commentId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Renew a checkout on an item
     * When you first get an item if checkout&#x3D;True you will have checked it out.  You should be showing a warning when the checkout is almost expired.  Calling this API will allow you to renew it. 
     * @param queueId The unique identifier for this queue
     * @param contentId The unique identifier for the content
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateItemCheckout(queueId: string, contentId: string, body?: Checkout, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2001>;
    public updateItemCheckout(queueId: string, contentId: string, body?: Checkout, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2001>>;
    public updateItemCheckout(queueId: string, contentId: string, body?: Checkout, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2001>>;
    public updateItemCheckout(queueId: string, contentId: string, body?: Checkout, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling updateItemCheckout.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling updateItemCheckout.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<InlineResponse2001>('put',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/items/${encodeURIComponent(String(contentId))}/checkout`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a custom param
     * You can customize some fields.  To get all the params use GET /inbox/queue/{queueId} 
     * @param queueId The unique identifier for this queue
     * @param paramId A custom configuration for a client
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateParam(queueId: string, paramId: string, body?: Body2, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateParam(queueId: string, paramId: string, body?: Body2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateParam(queueId: string, paramId: string, body?: Body2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateParam(queueId: string, paramId: string, body?: Body2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling updateParam.');
        }

        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling updateParam.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/inbox/queue/${encodeURIComponent(String(queueId))}/param/${encodeURIComponent(String(paramId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
